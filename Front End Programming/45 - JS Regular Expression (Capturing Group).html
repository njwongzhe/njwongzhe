<!DOCTYPE html> 
<html lang="en"> 

<head> 
    <title>JS Regular Expression (Capturing Group)</title> 
</head> 

<body> 
    <script> /* Capturing Group */
        console.log("------------------>>> Capturing Group");

        console.log(/World/g.exec("Hello World")); // Output: ['World', index: 6, input: 'Hello World', groups: undefined]
        console.log("Hello World".match(/World/)); // Output: ['World', index: 6, input: 'Hello World', groups: undefined]
        // The "exec" or "match" (Without "g" Flag) will not only store the string matched in array output.

        // It also provides additional properties such as:
        // index  - The position where the match was found in the input string.
        // input  - The original string that was searched.
        // groups - Any named capturing groups (undefined if none).

        // A capturing group groups a subpattern, allowing you to apply a quantifier to the entire group or use disjunctions within it. 
        // It memorizes information about the subpattern match, so that you can refer back to it later with a backreference or access the information through the match results.
    </script>

    <script> /* Application of Capturing Group */
        console.log("------------------>>> Application of Capturing Group");

        console.log("------------------>>> Capturing Group Declaration");

        // Syntax: /(capGroup)/

        console.log(/(World)/g.exec("Hello World")); // Output: (2) ['World', 'World', index: 6, input: 'Hello World', groups: undefined]
        // It will store two result in array. 
        // The 1st result is the result of matching. 
        // The 2nd result is the result of capturing group.

        console.log("------------------>>> Capturing Group Name");

        // Syntax: /(?<nameGroup>capGroup)/

        console.log(/(?<World>World)/g.exec("Hello World")); // Output: (2) ['World', 'World', index: 6, input: 'Hello World', groups: {…}]
        // We can name the capturing group we capture and it will store both name and corresponding string inside the properties "groups".

        let resArr = /(?<Group1>World)/g.exec("Hello World");
        console.log(resArr.groups.Group1); // Output: World
        // The capturing group we store in array can be called.

        console.log("------------------>>> Non-Capturing Group");

        // Syntax: /(?:nonCapGroup)/

        console.log(/(?:World)/g.exec("Hello World")); // Output: ['World', index: 6, input: 'Hello World', groups: undefined]
        // However, some of the situation we might need to use the bracket but we do not need the capturing group.
        // "?:" can be used to let the pattern inside bracket become non-capturing group.

        console.log("------------------>>> Backreference");
        
        // It is useful when matching duplicated content.

        // Syntax: /(capGroup)\groupIndex/

        let resBack1 = new RegExp(/(\d)\1+/, "g"); // We capture a digit as a capturing group and use a backreference to match the same digit repeated at least once after the first digit is captured.
        console.log(resBack1.exec("1112223333")); // Output: (2) ['111', '1', index: 0, input: '1112223333', groups: undefined]
        console.log(resBack1.exec("1112223333")); // Output: (2) ['222', '2', index: 3, input: '1112223333', groups: undefined]
        console.log(resBack1.exec("1112223333")); // Output: (2) ['3333', '3', index: 6, input: '1112223333', groups: undefined]

        // Syntax: /(?<groupName>capGroup)\k<groupName>/

        let resBack2 = new RegExp(/(?<num1>\d)\k<num1>+/, "g");
        console.log(resBack2.exec("1112223333")); // Output: (2) ['111', '1', index: 0, input: '1112223333', groups: {…}]
        console.log(resBack2.exec("1112223333")); // Output: (2) ['222', '2', index: 3, input: '1112223333', groups: {…}]
        console.log(resBack2.exec("1112223333")); // Output: (2) ['3333', '3', index: 6, input: '1112223333', groups: {…}]
    </script>

    <script> /* "replace" & Capturing Group */
        console.log("------------------>>> \"replace\" & Capturing Group");

        let regDate = /(?<year>\d{4})-(?:(?<month>\d{2})-(?<date>\d{2}))/g;
        let date = '2024-12-12, 2025-01-02, 2026-03-04';

        // Syntax: string.replace(searchValue, newValue)
        // Syntax: string.replaceAll(searchValue, newValue)
        // The "newValue" can be a function which has three parameters (matchValue, index, input).
        // However, when capturing group is applied, the parameters will more than three (matchValue, group1, group2, ... groupN, index, input, groups)

        console.log(regDate.exec(date)); // Output: (4) ['2024-12-12', '2024', '12', '12', index: 0, input: '2024-12-12, 2025-01-02, 2026-03-04', groups: {…}]
        console.log(regDate.exec(date)); // Output: (4) ['2025-01-02', '2025', '01', '02', index: 12, input: '2024-12-12, 2025-01-02, 2026-03-04', groups: {…}]
        console.log(regDate.exec(date)); // Output: (4) ['2026-03-04', '2026', '03', '04', index: 24, input: '2024-12-12, 2025-01-02, 2026-03-04', groups: {…}]
 
        console.log(date.replace(regDate, function (match, g1, g2, g3, index, input, groups) {
            return `${g3}/${g2}/${g1}`;
        })); // Output: 12/12/2024, 02/01/2025, 04/03/2026

        // The "newValue" can also be a format such as "$groupNum".
        console.log(date.replace(regDate, "$3/$2/$1")); // Output: 12/12/2024, 02/01/2025, 04/03/2026
    </script>
</body> 

</html>